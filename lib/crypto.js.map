{"version":3,"sources":["../src/crypto.js"],"names":["convertIfArray","Array","convertToUint8Array","taskID","awaiting","webCrypto","isNode","window","crypto","subtle","webkitSubtle","msCrypto","useWebCrypto","digest","useSha1Crypto","useSha256Crypto","finalizeTask","result","deferred","resolve","sha1Hash","bytes","console","error","e","bytesTyped","name","then","smartTimeout","immediate","sha1HashSync","sha256Hash","identity","sha256HashSync","aesEncrypt","keyBytes","ivBytes","aesDecrypt","encryptedBytes","factorize","pqPrimeFactorization","modPow","x","y","m","bytesModPow","CryptoWorker"],"mappings":"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","file":"crypto.js","sourcesContent":["import when from 'ramda/src/when'\nimport is from 'ramda/src/is'\nimport identity from 'ramda/src/identity'\nimport has from 'ramda/src/has'\nimport both from 'ramda/src/both'\nimport isNode from 'detect-node'\n\nimport blueDefer from './util/defer'\nimport smartTimeout from './util/smart-timeout'\nimport { convertToUint8Array, sha1HashSync, sha256HashSync,\n  aesEncryptSync, aesDecryptSync, convertToByteArray, convertToArrayBuffer,\n  pqPrimeFactorization, bytesModPow } from './bin'\n\nconst convertIfArray = when(is(Array), convertToUint8Array)\nconst taskID = 0\nconst awaiting = {}\nconst webCrypto = isNode\n  ? false\n  //eslint-disable-next-line\n  : window.crypto.subtle || window.crypto.webkitSubtle //TODO remove browser depends\n  //eslint-disable-next-line\n  || window.msCrypto && window.msCrypto.subtle\nconst useWebCrypto = webCrypto && !!webCrypto.digest\nlet useSha1Crypto = useWebCrypto\nlet useSha256Crypto = useWebCrypto\nconst finalizeTask = (taskID, result) => {\n  const deferred = awaiting[taskID]\n  if (deferred) {\n    // console.log(rework_d_T(), 'CW done')\n    deferred.resolve(result) //TODO Possibly, can be used as\n    delete awaiting[taskID]  //\n  }                          //    deferred = Promise.resolve()\n}                            //    deferred.resolve( result )\n\n//eslint-disable-next-line\nconst sha1Hash = bytes => {\n  if (useSha1Crypto) {\n    // We don't use buffer since typedArray.subarray(...).buffer gives the whole buffer and not sliced one.\n    // webCrypto.digest supports typed array\n    const bytesTyped = convertIfArray(bytes)\n    // console.log(rework_d_T(), 'Native sha1 start')\n    return webCrypto.digest({ name: 'SHA-1' }, bytesTyped).then(digest =>\n      // console.log(rework_d_T(), 'Native sha1 done')\n        digest, e => {\n      console.error('Crypto digest error', e)\n      useSha1Crypto = false\n      return sha1HashSync(bytes)\n    })\n  }\n  return smartTimeout.immediate(sha1HashSync, bytes)\n}\n\nconst sha256Hash = bytes => {\n  if (useSha256Crypto) {\n    const bytesTyped = convertIfArray(bytes)\n    // console.log(rework_d_T(), 'Native sha1 start')\n    return webCrypto.digest({ name: 'SHA-256' }, bytesTyped)\n      .then(identity\n        // console.log(rework_d_T(), 'Native sha1 done')\n        , e => {\n          console.error('Crypto digest error', e)\n          useSha256Crypto = false\n          return sha256HashSync(bytes)\n        })\n  }\n  return smartTimeout.immediate(sha256HashSync, bytes)\n}\n\nconst aesEncrypt = (bytes, keyBytes, ivBytes) =>\n  smartTimeout.immediate(() => convertToArrayBuffer(aesEncryptSync(bytes, keyBytes, ivBytes)))\n\nconst aesDecrypt = (encryptedBytes, keyBytes, ivBytes) =>\n  smartTimeout.immediate(() => convertToArrayBuffer(\n    aesDecryptSync(encryptedBytes, keyBytes, ivBytes)))\n\nconst factorize = bytes => {\n  bytes = convertToByteArray(bytes)\n  return smartTimeout.immediate(pqPrimeFactorization, bytes)\n}\n\nconst modPow = (x, y, m) => smartTimeout.immediate(bytesModPow, x, y, m)\n\nexport const CryptoWorker = {\n  sha1Hash,\n  sha256Hash,\n  aesEncrypt,\n  aesDecrypt,\n  factorize,\n  modPow\n}\n\nexport default CryptoWorker\n"]}