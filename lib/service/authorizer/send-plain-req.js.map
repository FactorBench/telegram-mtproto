{"version":3,"sources":["../../../src/service/authorizer/send-plain-req.js"],"names":["is404","notError","err","error","ErrorNotFound","ErrorBadResponse","Promise","reject","SendPlain","Serialization","Deserialization","platform","url","requestBuffer","requestLength","byteLength","requestArray","Int32Array","header","headBox","writer","WriteMediator","longP","long","int","headerBuffer","getBuffer","headerArray","headerLength","resultBuffer","ArrayBuffer","resultArray","set","length","requestData","reqPromise","httpClient","post","responseType","tcpClient","TCP","console","log","props","req","onlySendPlainReq","onlySendPlainErr","onlySendPlainRes","data","deserializer","mtproto","ctx","typeBuffer","ReadMediator","e","sendPlainReq","then"],"mappings":"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","file":"send-plain-req.js","sourcesContent":["//@flow\n\nimport Promise from 'bluebird'\n\nimport has from 'ramda/src/has'\nimport pathEq from 'ramda/src/pathEq'\nimport allPass from 'ramda/src/allPass'\n\nimport httpClient from '../../http'\nimport TCP from '../../tcp'\nimport { ErrorBadResponse, ErrorNotFound } from '../../error'\nimport { generateID } from '../time-manager'\nimport { WriteMediator, ReadMediator } from '../../tl'\n\nimport type { TLFabric } from '../../tl'\n\nconst is404 = pathEq(['response', 'status'], 404)\nconst notError = allPass([has('message'), has('type')])\n\nconst SendPlain = ({ Serialization, Deserialization }: TLFabric, platform) => {\n  const onlySendPlainReq = async (url: string, requestBuffer: ArrayBuffer) => {\n    const requestLength = requestBuffer.byteLength,\n          requestArray = new Int32Array(requestBuffer)\n\n    const header = Serialization()\n    const headBox = header.writer\n\n    WriteMediator.longP(headBox, 0, 0, 'auth_key_id') // Auth key\n    WriteMediator.long(headBox, generateID(), 'msg_id') // Msg_id\n    WriteMediator.int(headBox, requestLength, 'request_length')\n\n    const headerBuffer: ArrayBuffer = headBox.getBuffer(),\n          headerArray = new Int32Array(headerBuffer)\n    const headerLength = headerBuffer.byteLength\n\n    const resultBuffer = new ArrayBuffer(headerLength + requestLength),\n          resultArray = new Int32Array(resultBuffer)\n\n    resultArray.set(headerArray)\n    resultArray.set(requestArray, headerArray.length)\n\n    const requestData = resultArray\n    let reqPromise\n    // try {\n    if (platform == 'web') {\n      reqPromise = httpClient.post(url, requestData, { responseType: 'arraybuffer' })\n    } else {\n      const tcpClient = new TCP({url})\n      console.log(\"\\n>>> SENDPLAINREQ: \", url, \"<<<\\n\")\n      reqPromise = tcpClient.post(requestData)\n    }\n        // } catch (e) {\n    //   reqPromise = Promise.reject(new ErrorBadResponse(url, e))\n    // }\n    return Promise.props({ url, req: reqPromise })\n  }\n\n  const onlySendPlainErr = (err) => {\n    let error\n    switch (true) {\n      case is404(err):\n        error = new ErrorNotFound(err)\n        break\n      case notError(err):\n        error = new ErrorBadResponse('', err)\n        break\n      default:\n        error = err\n    }\n    return Promise.reject(error)\n  }\n\n  const onlySendPlainRes = ({ url, req }) => {\n    if (!req.data || !req.data.byteLength)\n      return Promise.reject(new ErrorBadResponse(url))\n    let deserializer\n    try {\n      deserializer = Deserialization(req.data, { mtproto: true })\n      const ctx = deserializer.typeBuffer\n      ReadMediator.long(ctx, 'auth_key_id')\n      ReadMediator.long(ctx, 'msg_id')\n      ReadMediator.int(ctx, 'msg_len')\n    } catch (e) {\n      return Promise.reject(new ErrorBadResponse(url, e))\n    }\n\n    return deserializer\n  }\n\n  const sendPlainReq = (url: string, requestBuffer: ArrayBuffer) =>\n    onlySendPlainReq(url, requestBuffer)\n      .then(\n        onlySendPlainRes,\n        onlySendPlainErr)\n\n  return sendPlainReq\n}\n\nexport default SendPlain"]}