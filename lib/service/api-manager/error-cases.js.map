{"version":3,"sources":["../../../src/service/api-manager/error-cases.js"],"names":["cachedExportPromise","protect","code","NaN","type","rawError","dcID","baseDcID","base","errR","patterns","noBaseAuth","noDcAuth","waitFail","_","matchProtect","matched","error","options","emit","rejectPromise","requestThunk","apiSavedNet","apiRecall","deferResolve","mtpInvokeApi","storage","invoke","throwNext","reject","console","log","remove","importAuth","id","bytes","noErrorBox","exportDeferred","resolve","e","dc_id","then","exportedAuth","promise","catch","fileMigrate","now","stopTime","waitTime","Math","min","def","switchErrors"],"mappings":"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","file":"error-cases.js","sourcesContent":["import isNil from 'ramda/src/isNil'\nimport propOr from 'ramda/src/propOr'\n\nimport blueDefer from '../../util/defer'\nimport Switch from '../../util/switch'\nimport { tsNow } from '../time-manager'\n\nconst cachedExportPromise = {}\n\nconst protect = (\n    { code = NaN, type = '' },\n    { rawError = null },\n    dcID,\n    baseDcID\n  ) => ({\n    base: baseDcID,\n    errR: rawError,\n    code,\n    type,\n    dcID\n  })\n\nconst patterns = {\n  noBaseAuth: ({ code, dcID, base, type })  =>  code == 401 && dcID == base && type != 'SESSION_PASSWORD_NEEDED',\n  noDcAuth: ({ code, dcID, base, type })  =>  code === 401 && dcID !== base && type !== 'SESSION_PASSWORD_NEEDED',// && type === 'AUTH_KEY_UNREGISTERED',\n  waitFail: ({ code, type, errR })  =>  !errR && (code === 500 || type === 'MSG_WAIT_FAILED'),\n  //fileMigrate: ({ code, type }) => code === 303 && type.slice(0, -1) === 'FILE_MIGRATE_',\n  _ : () => true\n}\n\n\nconst matchProtect =\n  matched => (\n      error,\n      options,\n      dcID,\n      emit,\n      rejectPromise,\n      requestThunk,\n      apiSavedNet,\n      apiRecall,\n      deferResolve,\n      mtpInvokeApi,\n      storage\n    ) =>\n      matched({\n        invoke   : mtpInvokeApi,\n        throwNext: () => rejectPromise(error),\n        reject   : rejectPromise,\n        options,\n        dcID,\n        emit,\n        requestThunk,\n        apiRecall,\n        deferResolve,\n        apiSavedNet,\n        storage\n      })\n\n\nconst noBaseAuth = ({ emit, throwNext, storage }) => {\n  console.log('[noBaseAuth]')\n  storage.remove('dc', 'user_auth')\n  emit('error.401.base')\n  throwNext()\n}\n\nconst noDcAuth = ({ dcID, reject, apiSavedNet, apiRecall, deferResolve, invoke }) => {\n  console.log('[noDcAuth:0]', { dcID })\n  const importAuth = ({ id, bytes }) => invoke(\n    'auth.importAuthorization',\n    { id, bytes },\n    { dcID, noErrorBox: true })\n\n  console.log('[noDcAuth:1] check stored:', cachedExportPromise[dcID], isNil(cachedExportPromise[dcID]))\n  console.log('[noDcAuth:1.1]', cachedExportPromise)\n  if (isNil(cachedExportPromise[dcID])) {\n    console.log('[noDcAuth:2] start to transfer authorization')\n    const exportDeferred = blueDefer()\n\n                /* mtpInvokeApi('auth.exportAuthorization', {dc_id: dcID}, {noErrorBox: true}).then(function (exportedAuth) {\n                  mtpInvokeApi('auth.importAuthorization', {\n                    id: exportedAuth.id,\n                    bytes: exportedAuth.bytes\n                  }, {dcID: dcID, noErrorBox: true}).then(function () {\n                    exportDeferred.resolve()\n                  }, function (e) {\n                    exportDeferred.reject(e)\n                  })\n                }, function (e) {\n                  exportDeferred.reject(e)\n                })\n\n                cachedExportPromise[dcID] = exportDeferred.promise */\n\n\n    invoke('auth.exportAuthorization', { dc_id: dcID }, { noErrorBox: true })\n      .then(function({exportedAuth}) {\n        console.log('[noDcAuth:3] for import:', { exportedAuth })\n        importAuth({ id, bytes }).then(function() {\n          console.log('[noDcAuth:3.1] imported')\n          exportDeferred.resolve()\n        }, function(e) {\n          console.log('[noDcAuth:3.2] import failed:', e)\n          exportDeferred.reject(e)\n        })\n      }, function(e) {\n        console.log('[noDcAuth:4] export failed:', e)\n        exportDeferred.reject(e)\n      })\n      //.then(importAuth)\n      //.then(exportDeferred.resolve)\n      //.catch(exportDeferred.reject)\n\n    cachedExportPromise[dcID] = exportDeferred.promise\n  }\n\n  cachedExportPromise[dcID] //TODO not returning promise\n    .then(apiSavedNet)\n    .then(apiRecall)\n    .then(deferResolve)\n    .catch(reject)\n}\n\nconst fileMigrate = () => {\n\n}\n/*\nconst migrate = ({ error, dcID, options, reject,\n    apiRecall, deferResolve, getNet, storage\n  }) => {\n  const newDcID = error.type.match(/^(PHONE_MIGRATE_|NETWORK_MIGRATE_|USER_MIGRATE_)(\\d+)/)[2]\n  if (newDcID === dcID) return\n  if (options.dcID)\n    options.dcID = newDcID\n  else\n    storage.set('dc', newDcID)\n\n  getNet(newDcID, options)\n    .then(apiRecall)\n    .then(deferResolve)\n    .catch(reject)\n}*/\n\n/*const floodWait = ({ error, options, throwNext, requestThunk }) => {\n  const waitTime = error.type.match(/^FLOOD_WAIT_(\\d+)/)[1] || 10\n  if (waitTime > (options.timeout || 60))\n    return throwNext()\n  requestThunk(waitTime)\n}*/\n\nconst waitFail = ({ options, throwNext, requestThunk }) => {\n  const now = tsNow()\n  if (options.stopTime) {\n    if (now >= options.stopTime)\n      return throwNext()\n  } else {\n    options.stopTime = now + propOr(10, 'timeout', options) * 1000\n  }\n  options.waitTime = options.waitTime\n    ? Math.min(60, options.waitTime * 1.5)\n    : 1\n  requestThunk(options.waitTime)\n}\n\nconst def = ({ throwNext }) => throwNext()\n\n\nexport const switchErrors = Switch(patterns, protect)({\n  noBaseAuth,\n  noDcAuth,\n  waitFail,\n  _: def\n}, matchProtect)"]}