{"version":3,"sources":["../src/tcp.js"],"names":["log","msg1","msg2","console","reURL","RegExp","modes","TCP","constructor","host","port","url","socket","mode","_parseUrl","net","Socket","seqNo","intermediateModeInited","isConnected","isClosed","toLowerCase","includes","hadError","connect","on","Promise","resolve","reject","connectHandler","removeListener","errorHandler","isInited","write","Buffer","alloc","initHandler","err","data","once","post","message","buffer","encapsulate","byteLength","length","decapsulate","toString","endsWith","destroy","int32Message","Int32Array","set","from","readInt32LE","slice","bufferLength","Error","wait","timeout","setTimeout","_destroy","exception","indexOf","exec"],"mappings":"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","file":"tcp.js","sourcesContent":["'use strict'\n\nimport { Buffer } from 'buffer'\nimport net from 'net'\n\nimport Logger from './util/log'\nimport crc32 from './crc32'\n\n//const log = Logger`tcp`\nconst log = (msg1) => (msg2) => console.log(`[${msg1}]`, msg2)\n\nconst reURL = new RegExp(/([0-9.]+):(80|443)/)\n\nconst modes = ['full', 'abridged', 'intermediate']\n\nclass TCP {\n    constructor({ host, port, url, socket, mode }) {\n        if (url) [host, port] = this._parseUrl(url)\n\n        this.host = host\n        this.port = 80//port\n        this.socket = socket || new net.Socket()\n        //this.socket._destroy = this._destroy.bind(this)\n        this.seqNo = 0\n        this.intermediateModeInited = false\n        this.isConnected = false\n        this.isClosed = false\n\n        if (mode) mode = mode.toLowerCase()\n        this.mode = modes.includes(mode) ? mode : 'intermediate'\n\n        this.socket.on('close', async (hadError) => {\n            this.isConnected = false\n            // TODO limit reconnection tries\n            log('close')('connection closed')\n            if (hadError) {\n                log('close')('try to reconnect...')\n                await this.connect()\n            }\n        })\n    }\n\n    connect() {\n        return new Promise((resolve, reject) => {\n            const connectHandler = () => {\n                this.isConnected = true\n                log('connect')(`connected to ${this.host}:${this.port}`)\n                this.socket.removeListener('error', errorHandler)\n\n                if (this.mode === 'intermediate' && !this.intermediateModeInited) {\n                    // init connection\n                    const isInited = this.socket.write(Buffer.alloc(4, 0xee))\n                    log(['connect', 'sent'])(`init packet sending ${isInited ? 'successful' : 'failure'}`)\n                } else {\n                    this.socket.removeListener('data', initHandler)\n                }\n                resolve(this.socket)\n            }\n            const errorHandler = (err) => {\n                log('connect')('failed:', err)\n                this.socket.removeListener('connect', connectHandler)\n                this.socket.removeListener('data', initHandler)\n\n                reject(err)\n            }\n            const initHandler = (data) => {\n                log('connect')(`rcvd on initialization packet:`, data)\n                this.intermediateModeInited = true\n                //resolve()\n            }\n\n            if (this.isConnected) {\n                this.socket.removeListener('connect', connectHandler)\n                this.socket.removeListener('data', initHandler)\n                this.socket.removeListener('error', errorHandler)\n                resolve(this.socket)\n            } else {\n                this.socket.on('error', errorHandler)\n                this.socket.once('data', initHandler)\n                this.socket.connect(this.port, this.host, connectHandler)\n            }\n        })\n    }\n\n    post(message) {\n        const buffer = this.encapsulate(message)\n\n        return new Promise(async (resolve, reject) => {\n            if (!this.isConnected) await this.connect()\n\n            log(['post', `sent.${this.seqNo}`])(`${buffer.byteLength} bytes`)\n\n            if (this.socket.write(buffer)) {\n                log(['post'])(`passed to kernel. seqNo => ${this.seqNo}`)\n                this.seqNo++\n            } else {\n                this.socket.once('drain', () => {\n                    log(['post'])(`drained. seqNo => ${this.seqNo}`)\n                    this.seqNo++\n                })\n            }\n\n            this.socket.once('data', (data) => {\n                const { length, seqNo, message } = this.decapsulate(data)\n                log(['post', `rcvd.${seqNo}`])(`data ${data.length} bytes, message ${message.length} bytes`)\n\n                if (message.toString().endsWith('exit')) {\n                    this.socket.destroy()\n                }\n                resolve({ data: message })\n            })\n\n            this.socket.once('error', (err) => {\n                reject(err)\n            })\n        })\n    }\n\n    encapsulate(message) {\n        const int32Message = new Int32Array(message)\n        const data = new Int32Array(int32Message.length + 1)\n\n        data[0] = int32Message.byteLength\n        data.set(int32Message, 1)\n        log('encapsulate')(data.toString())\n        return Buffer.from(data.buffer)\n    }\n\n    decapsulate(buffer) {\n        log('decapsulate')(`${buffer.byteLength} bytes`)\n        const length = buffer.readInt32LE(0),\n            message = buffer.slice(4),\n            seqNo = 0\n\n        if (length !== message.length) {\n            log(['decapsulate', 'error'])({ length, bufferLength: buffer.length })\n            log(['decapsulate', 'error'])(buffer)\n            throw new Error('BAD_RESPONSE_LENGTH')\n        }\n\n        return { length, seqNo, message }\n    }\n\n    wait(timeout) {\n        return new Promise((resolve) => {\n            setTimeout(() => resolve(), timeout)\n        })\n    }\n\n    _destroy(exception) {\n        log('_destroy')('socket destroyed')\n        this.isClosed = exception ? false : true\n        if (exception) log('_destroy')(exception)\n    }\n\n    _parseUrl(url) {\n        let host, port\n\n        if (url && url.indexOf(':', 6) > 6) {\n            [, host, port] = reURL.exec(url)\n        }\n        return [host, port]\n    }\n}\n\nexport default TCP"]}