{"version":3,"sources":["../src/tcp.js"],"names":["log","msg1","msg2","console","reURL","RegExp","modes","TCP","constructor","host","port","url","socket","mode","_parseUrl","net","Socket","seqNo","intermediateModeInited","isClosed","toLowerCase","includes","hadError","connect","on","Promise","resolve","reject","connectHandler","removeListener","errorHandler","isInited","write","Buffer","alloc","initHandler","err","data","_handle","once","post","message","buffer","encapsulate","byteLength","length","decapsulate","toString","endsWith","destroy","Int32Array","set","from","readInt32LE","slice","bufferLength","Error","wait","timeout","setTimeout","_destroy","exception","indexOf","exec"],"mappings":"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","file":"tcp.js","sourcesContent":["'use strict'\n\nimport { Buffer } from 'buffer'\nimport net from 'net'\n\nimport Logger from './util/log'\nimport crc32 from './crc32'\n\n//const log = Logger`tcp`\nconst log = (msg1) => (msg2) => console.log(`[${msg1}]`, msg2)\n\nconst reURL = new RegExp(/([0-9.]+):(80|443)/)\n\nconst modes = ['full', 'abridged', 'intermediate']\n\nclass TCP {\n    constructor({ host, port, url, socket, mode }) {\n        if (url) [host, port] = this._parseUrl(url)\n\n        this.host = host\n        this.port = 80//port\n        this.socket = socket || new net.Socket()\n        //this.socket._destroy = this._destroy.bind(this)\n        this.seqNo = 0\n        this.intermediateModeInited = false\n        this.isClosed = false\n\n        if (mode) mode = mode.toLowerCase()\n        this.mode = modes.includes(mode) ? mode : 'intermediate'\n\n        this.socket.on('close', async (hadError) => {\n            // TODO limit reconnection tries\n            log('close')('connection closed')\n            if (hadError) {\n                log('close')('try to reconnect...')\n                await this.connect()\n            }\n        })\n    }\n\n    connect() {\n        return new Promise((resolve, reject) => {\n            const connectHandler = () => {\n                log('connect')(`connected to ${this.host}:${this.port}`)\n                this.socket.removeListener('error', errorHandler)\n\n                if (this.mode === 'intermediate' && !this.intermediateModeInited) {\n                    // init connection\n                    const isInited = this.socket.write(Buffer.alloc(4, 0xee))\n                    log(['connect', 'sent'])(`init packet sending ${isInited ? 'successful' : 'failure'}`)\n                } else {\n                    this.socket.removeListener('data', initHandler)\n                }\n                resolve(this.socket)\n            }\n            const errorHandler = (err) => {\n                log('connect')('failed:', err)\n                this.socket.removeListener('connect', connectHandler)\n                this.socket.removeListener('data', initHandler)\n\n                reject(err)\n            }\n            const initHandler = (data) => {\n                log('connect')(`rcvd on initialization packet:`, data)\n                this.intermediateModeInited = true\n                //resolve()\n            }\n\n            if (this.socket._handle !== null) {\n                this.socket.removeListener('connect', connectHandler)\n                this.socket.removeListener('data', initHandler)\n                this.socket.removeListener('error', errorHandler)\n                resolve(this.socket)\n            } else {\n                this.socket.on('error', errorHandler)\n                this.socket.once('data', initHandler)\n                this.socket.connect(this.port, this.host, connectHandler)\n            }\n        })\n    }\n\n    post(message) {\n        const buffer = this.encapsulate(message)\n\n        return new Promise(async (resolve, reject) => {\n            if (this.socket._handle === null) await this.connect()\n\n            log(['post', `sent.${this.seqNo}`])(`${buffer.byteLength} bytes`)\n\n            if (this.socket.write(buffer)) {\n                log(['post'])(`passed to kernel. seqNo => ${this.seqNo}`)\n                this.seqNo++\n            } else {\n                this.socket.once('drain', () => {\n                    log(['post'])(`drained. seqNo => ${this.seqNo}`)\n                    this.seqNo++\n                })\n            }\n\n            this.socket.once('data', (data) => {\n                const { length, seqNo, message } = this.decapsulate(data)\n                log(['post', `rcvd.${seqNo}`])(`data ${data.length} bytes, message ${message.length} bytes`)\n\n                if (message.toString().endsWith('exit')) {\n                    this.socket.destroy()\n                }\n                resolve({ data: message })\n            })\n\n            this.socket.once('error', (err) => {\n                reject(err)\n            })\n        })\n    }\n\n    encapsulate(message) {\n        const data = new Int32Array(message.length + 1)\n\n        data[0] = message.byteLength\n        data.set(message, 1)\n        log('encapsulate')(data.toString())\n        return Buffer.from(data.buffer)\n    }\n\n    decapsulate(buffer) {\n        log('decapsulate')(`${buffer.byteLength} bytes`)\n        const length = buffer.readInt32LE(0),\n            message = buffer.slice(4),\n            seqNo = 0\n\n        if (length !== message.length) {\n            log(['decapsulate', 'error'])({ length, bufferLength: buffer.length })\n            log(['decapsulate', 'error'])(buffer)\n            throw new Error('BAD_RESPONSE_LENGTH')\n        }\n\n        return { length, seqNo, message }\n    }\n\n    wait(timeout) {\n        return new Promise((resolve) => {\n            setTimeout(() => resolve(), timeout)\n        })\n    }\n\n    _destroy(exception) {\n        log('_destroy')('socket destroyed')\n        this.isClosed = exception ? false : true\n        if (exception) log('_destroy')(exception)\n    }\n\n    _parseUrl(url) {\n        let host, port\n\n        if (url && url.indexOf(':', 6) > 6) {\n            [, host, port] = reURL.exec(url)\n        }\n        return [host, port]\n    }\n}\n\nexport default TCP"]}